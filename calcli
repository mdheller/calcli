#!/usr/bin/python3

import easywebdav
import netrc
import vobject
import os
import re
import datetime
import calendar
import dateutil.parser
import argparse
import pytz
import tzlocal
import sys
import configparser
import logging

log = logging.getLogger("calcli")
tz = tzlocal.get_localzone()

class DTRange:
    re_day = re.compile(R"^\d{1,2}$")
    re_monthday = re.compile(R"^\d{1,2}-\d{1,2}$")
    re_yearmonth = re.compile(R"^\d{4}-\d{1,2}$")
    re_ymd = re.compile(R"\d{4}-\d{1,2}-\d{1,2}$")

    def __init__(self, since=None, until=None):
        """
        Datetime range. None in one extreme means open ended.
        """
        self.since = since
        self.until = until

    def match(self, evt):
        since, until = evt.since, evt.until
        if until is None: until = since
        if self.since is not None and until < self.since: return False
        if self.until is not None and since > self.until: return None
        return True

    @classmethod
    def parse_range(cls, arg):
        if cls.re_day.match(arg):
            # DD
            date = datetime.date.today().replace(day=int(arg))
            return (datetime.datetime.combine(date, datetime.time(0, 0, 0)).replace(tzinfo=tz),
                    datetime.datetime.combine(date, datetime.time(23, 59, 59)).replace(tzinfo=tz))
        elif cls.re_monthday.match(arg):
            # MM-DD
            month, day = (int(x) for x in arg.split("-"))
            date = datetime.date.today().replace(month=month, day=day)
            return (datetime.datetime.combine(date, datetime.time(0, 0, 0)).replace(tzinfo=tz),
                    datetime.datetime.combine(date, datetime.time(23, 59, 59)).replace(tzinfo=tz))
        elif cls.re_yearmonth.match(arg):
            # YYYY-MM
            year, month = (int(x) for x in arg.split("-"))
            return (datetime.datetime(year, month, 1, 0, 0, 0).replace(tzinfo=tz),
                    datetime.datetime(year, month, calendar.monthrange(year, month)[1], 23, 59, 59).replace(tzinfo=tz))
        elif cls.re_ymd.match(arg):
            # YYYY-MM-DD
            date = datetime.date(*(int(x) for x in arg.split("-")))
            return (datetime.datetime.combine(date, datetime.time(0, 0, 0)).replace(tzinfo=tz),
                    datetime.datetime.combine(date, datetime.time(23, 59, 59)).replace(tzinfo=tz))
        else:
            raise RuntimeError("No fallback to dateutils.parse implemented yet")



class Filter:
    def __init__(self, args):
        self.filters = []
        for a in args:
            if a.startswith("since:"):
                # since:<dt>
                since, until = DTRange.parse_range(a[6:])
                self.filters.append(DTRange(since=since))
            elif a.startswith("until:"):
                # until:<dt>
                since, until = DTRange.parse_range(a[6:])
                self.filters.append(DTRange(until=until))
            else:
                since, until = DTRange.parse_range(a)
                self.filters.append(DTRange(since, until))

    def match(self, evt):
        for f in self.filters:
            if not f.match(evt): return False
        return True


def print_event(evt, file=None):
    summary = evt.summary
    if evt.allday:
        since = evt.start
        until = evt.end
        if since == until:
            print("{day}: {summary}".format(day=since, summary=summary), file=file)
        else:
            print("{since:%Y-%m-%d} to {until:%Y-%m-%d}: {summary}".format(
                since=since,
                until=until,
                summary=summary), file=file)
    else:
        since = evt.start
        until = evt.end
        if until is None:
            print("{day} {since:%H:%M}: {summary}".format(
                day=since.date(),
                since=since.time(),
                summary=summary), file=file)
        elif since.date() == until.date():
            print("{day} {since:%H:%M}-{until:%H:%M}: {summary}".format(
                day=since.date(),
                since=since.time(),
                until=until.time(),
                summary=summary), file=file)
        else:
            print("{since:%Y-%m-%d %H:%M} to {until:%Y-%m-%d %H:%M}: {summary}".format(
                since=since,
                until=until,
                summary=summary), file=file)


class Events:
    def __init__(self):
        from khal import cli, khalendar
        self.conf = cli.get_config(None)

        props = {}
        for name, cal in self.conf['calendars'].items():
            props[name] = {
                'name': name,
                'path': cal['path'],
                'readonly': cal['readonly'],
                'color': cal['color'],
                'ctype': cal['type'],
            }
        self.collection = khalendar.CalendarCollection(
            calendars=props,
            color=self.conf['highlight_days']['color'],
            locale=self.conf['locale'],
            dbpath=self.conf['sqlite']['path'],
            hmethod=self.conf['highlight_days']['method'],
            default_color=self.conf['highlight_days']['default_color'],
            multiple=self.conf['highlight_days']['multiple'],
            highlight_event_days=self.conf['default']['highlight_event_days'],
        )

    @property
    def events(self):
        minimal = False
        now = datetime.datetime.now()
        begin = now - datetime.timedelta(days=1)
        until = now + datetime.timedelta(days=10)
        yield from self.collection.get_floating(begin, until, minimal)
        localize = self.collection._locale['local_timezone'].localize
        yield from self.collection.get_localized(localize(begin), localize(until), minimal)


class Command:
    def __init__(self, filter_args, args):
        self.filter_args = filter_args
        self.args = args

    @classmethod
    def get_name(cls):
        return cls.__name__.lower()


class Next(Command):
    def run(self, events):
        self.flt = Filter(self.filter_args)
        #events.load()
        for e in events.events:
            #if not self.flt.match(e): continue
            #e.print_line()
            print_event(e)


def make_command(commands, args):
    filter_args = []
    command = None
    cmd_args = []
    for a in args.args:
        if command is None:
            for c in commands:
                if c.get_name() == a:
                    command = c
                    break
            else:
                filter_args.append(a)
        else:
            cmd_args.append(a)

    if command is None:
        return Next(filter_args, [])
    else:
        return command(filter_args, cmd_args)


def main():
    parser = argparse.ArgumentParser(description="Command line calendar tool.")
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="verbose output")
    parser.add_argument("args", nargs="*", help="[filter] command [args]")
    args = parser.parse_args()

    FORMAT = "%(asctime)-15s %(levelname)s %(message)s"
    if args.debug:
        logging.basicConfig(level=logging.DEBUG, stream=sys.stderr, format=FORMAT)
    elif args.verbose:
        logging.basicConfig(level=logging.INFO, stream=sys.stderr, format=FORMAT)
    else:
        logging.basicConfig(level=logging.WARN, stream=sys.stderr, format=FORMAT)

    events = Events()

    commands = [
        Next,
    ]

    cmd = make_command(commands, args)
    cmd.run(events)


if __name__ == "__main__":
    main()
